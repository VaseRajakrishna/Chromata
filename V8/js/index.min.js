var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {},
    Prism = function() {
        var e = /\blang(?:uage)?-(\w+)\b/i,
            t = 0,
            n = _self.Prism = {
                util: {
                    encode: function(e) {
                        return e instanceof i ? new i(e.type, n.util.encode(e.content), e.alias) : "Array" === n.util.type(e) ? e.map(n.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ")
                    },
                    type: function(e) {
                        return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]
                    },
                    objId: function(e) {
                        return e.__id || Object.defineProperty(e, "__id", {
                            value: ++t
                        }), e.__id
                    },
                    clone: function(e) {
                        switch (n.util.type(e)) {
                            case "Object":
                                var t = {};
                                for (var i in e) e.hasOwnProperty(i) && (t[i] = n.util.clone(e[i]));
                                return t;
                            case "Array":
                                return e.map && e.map(function(e) {
                                    return n.util.clone(e)
                                })
                        }
                        return e
                    }
                },
                languages: {
                    extend: function(e, t) {
                        var i = n.util.clone(n.languages[e]);
                        for (var r in t) i[r] = t[r];
                        return i
                    },
                    insertBefore: function(e, t, i, r) {
                        var o = (r = r || n.languages)[e];
                        if (2 == arguments.length) {
                            for (var s in i = arguments[1]) i.hasOwnProperty(s) && (o[s] = i[s]);
                            return o
                        }
                        var a = {};
                        for (var l in o)
                            if (o.hasOwnProperty(l)) {
                                if (l == t)
                                    for (var s in i) i.hasOwnProperty(s) && (a[s] = i[s]);
                                a[l] = o[l]
                            }
                        return n.languages.DFS(n.languages, function(t, n) {
                            n === r[e] && t != e && (this[t] = a)
                        }), r[e] = a
                    },
                    DFS: function(e, t, i, r) {
                        for (var o in r = r || {}, e) e.hasOwnProperty(o) && (t.call(e, o, e[o], i || o), "Object" !== n.util.type(e[o]) || r[n.util.objId(e[o])] ? "Array" !== n.util.type(e[o]) || r[n.util.objId(e[o])] || (r[n.util.objId(e[o])] = !0, n.languages.DFS(e[o], t, o, r)) : (r[n.util.objId(e[o])] = !0, n.languages.DFS(e[o], t, null, r)))
                    }
                },
                plugins: {},
                highlightAll: function(e, t) {
                    var i = {
                        callback: t,
                        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                    };
                    n.hooks.run("before-highlightall", i);
                    for (var r, o = i.elements || document.querySelectorAll(i.selector), s = 0; r = o[s++];) n.highlightElement(r, !0 === e, i.callback)
                },
                highlightElement: function(t, i, r) {
                    for (var o, s, a = t; a && !e.test(a.className);) a = a.parentNode;
                    a && (o = (a.className.match(e) || [, ""])[1].toLowerCase(), s = n.languages[o]), t.className = t.className.replace(e, "").replace(/\s+/g, " ") + " language-" + o, a = t.parentNode, /pre/i.test(a.nodeName) && (a.className = a.className.replace(e, "").replace(/\s+/g, " ") + " language-" + o);
                    var l = {
                        element: t,
                        language: o,
                        grammar: s,
                        code: t.textContent
                    };
                    if (n.hooks.run("before-sanity-check", l), l.code && l.grammar)
                        if (n.hooks.run("before-highlight", l), i && _self.Worker) {
                            var c = new Worker(n.filename);
                            c.onmessage = function(e) {
                                l.highlightedCode = e.data, n.hooks.run("before-insert", l), l.element.innerHTML = l.highlightedCode, r && r.call(l.element), n.hooks.run("after-highlight", l), n.hooks.run("complete", l)
                            }, c.postMessage(JSON.stringify({
                                language: l.language,
                                code: l.code,
                                immediateClose: !0
                            }))
                        } else l.highlightedCode = n.highlight(l.code, l.grammar, l.language), n.hooks.run("before-insert", l), l.element.innerHTML = l.highlightedCode, r && r.call(t), n.hooks.run("after-highlight", l), n.hooks.run("complete", l);
                    else n.hooks.run("complete", l)
                },
                highlight: function(e, t, r) {
                    var o = n.tokenize(e, t);
                    return i.stringify(n.util.encode(o), r)
                },
                tokenize: function(e, t) {
                    var i = n.Token,
                        r = [e],
                        o = t.rest;
                    if (o) {
                        for (var s in o) t[s] = o[s];
                        delete t.rest
                    }
                    e: for (var s in t)
                        if (t.hasOwnProperty(s) && t[s]) {
                            var a = t[s];
                            a = "Array" === n.util.type(a) ? a : [a];
                            for (var l = 0; l < a.length; ++l) {
                                var c = a[l],
                                    u = c.inside,
                                    d = !!c.lookbehind,
                                    g = !!c.greedy,
                                    h = 0,
                                    p = c.alias;
                                if (g && !c.pattern.global) {
                                    var m = c.pattern.toString().match(/[imuy]*$/)[0];
                                    c.pattern = RegExp(c.pattern.source, m + "g")
                                }
                                c = c.pattern || c;
                                for (var f = 0, y = 0; f < r.length; y += (r[f].matchedStr || r[f]).length, ++f) {
                                    var b = r[f];
                                    if (r.length > e.length) break e;
                                    if (!(b instanceof i)) {
                                        c.lastIndex = 0;
                                        var v = 1;
                                        if (!(S = c.exec(b)) && g && f != r.length - 1) {
                                            if (c.lastIndex = y, !(S = c.exec(e))) break;
                                            for (var w = S.index + (d ? S[1].length : 0), k = S.index + S[0].length, _ = f, I = y, E = r.length; E > _ && k > I; ++_) w >= (I += (r[_].matchedStr || r[_]).length) && (++f, y = I);
                                            if (r[f] instanceof i || r[_ - 1].greedy) continue;
                                            v = _ - f, b = e.slice(y, I), S.index -= y
                                        }
                                        if (S) {
                                            d && (h = S[1].length);
                                            k = (w = S.index + h) + (S = S[0].slice(h)).length;
                                            var S, x = b.slice(0, w),
                                                P = b.slice(k),
                                                T = [f, v];
                                            x && T.push(x);
                                            var A = new i(s, u ? n.tokenize(S, u) : S, p, S, g);
                                            T.push(A), P && T.push(P), Array.prototype.splice.apply(r, T)
                                        }
                                    }
                                }
                            }
                        }
                    return r
                },
                hooks: {
                    all: {},
                    add: function(e, t) {
                        var i = n.hooks.all;
                        i[e] = i[e] || [], i[e].push(t)
                    },
                    run: function(e, t) {
                        var i = n.hooks.all[e];
                        if (i && i.length)
                            for (var r, o = 0; r = i[o++];) r(t)
                    }
                }
            },
            i = n.Token = function(e, t, n, i, r) {
                this.type = e, this.content = t, this.alias = n, this.matchedStr = i || null, this.greedy = !!r
            };
        if (i.stringify = function(e, t, r) {
                if ("string" == typeof e) return e;
                if ("Array" === n.util.type(e)) return e.map(function(n) {
                    return i.stringify(n, t, e)
                }).join("");
                var o = {
                    type: e.type,
                    content: i.stringify(e.content, t, r),
                    tag: "span",
                    classes: ["token", e.type],
                    attributes: {},
                    language: t,
                    parent: r
                };
                if ("comment" == o.type && (o.attributes.spellcheck = "true"), e.alias) {
                    var s = "Array" === n.util.type(e.alias) ? e.alias : [e.alias];
                    Array.prototype.push.apply(o.classes, s)
                }
                n.hooks.run("wrap", o);
                var a = "";
                for (var l in o.attributes) a += (a ? " " : "") + l + '="' + (o.attributes[l] || "") + '"';
                return "<" + o.tag + ' class="' + o.classes.join(" ") + '"' + (a ? " " + a : "") + ">" + o.content + "</" + o.tag + ">"
            }, !_self.document) return _self.addEventListener ? (_self.addEventListener("message", function(e) {
            var t = JSON.parse(e.data),
                i = t.language,
                r = t.code,
                o = t.immediateClose;
            _self.postMessage(n.highlight(r, n.languages[i], i)), o && _self.close()
        }, !1), _self.Prism) : _self.Prism;
        var r = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
        return r && (n.filename = r.src, document.addEventListener && !r.hasAttribute("data-manual") && ("loading" !== document.readyState ? window.requestAnimationFrame ? window.requestAnimationFrame(n.highlightAll) : window.setTimeout(n.highlightAll, 16) : document.addEventListener("DOMContentLoaded", n.highlightAll))), _self.Prism
    }();
"undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism), Prism.languages.markup = {
        comment: /<!--[\w\W]*?-->/,
        prolog: /<\?[\w\W]+?\?>/,
        doctype: /<!DOCTYPE[\w\W]+?>/i,
        cdata: /<!\[CDATA\[[\w\W]*?]]>/i,
        tag: {
            pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
            inside: {
                tag: {
                    pattern: /^<\/?[^\s>\/]+/i,
                    inside: {
                        punctuation: /^<\/?/,
                        namespace: /^[^\s>\/:]+:/
                    }
                },
                "attr-value": {
                    pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
                    inside: {
                        punctuation: /[=>"']/
                    }
                },
                punctuation: /\/?>/,
                "attr-name": {
                    pattern: /[^\s>\/]+/,
                    inside: {
                        namespace: /^[^\s>\/:]+:/
                    }
                }
            }
        },
        entity: /&#?[\da-z]{1,8};/i
    }, Prism.hooks.add("wrap", function(e) {
        "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"))
    }), Prism.languages.xml = Prism.languages.markup, Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.css = {
        comment: /\/\*[\w\W]*?\*\//,
        atrule: {
            pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
            inside: {
                rule: /@[\w-]+/
            }
        },
        url: /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
        selector: /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
        string: {
            pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
            greedy: !0
        },
        property: /(\b|\B)[\w-]+(?=\s*:)/i,
        important: /\B!important\b/i,
        function: /[-a-z0-9]+(?=\()/i,
        punctuation: /[(){};:]/
    }, Prism.languages.css.atrule.inside.rest = Prism.util.clone(Prism.languages.css), Prism.languages.markup && (Prism.languages.insertBefore("markup", "tag", {
        style: {
            pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
            lookbehind: !0,
            inside: Prism.languages.css,
            alias: "language-css"
        }
    }), Prism.languages.insertBefore("inside", "attr-value", {
        "style-attr": {
            pattern: /\s*style=("|').*?\1/i,
            inside: {
                "attr-name": {
                    pattern: /^\s*style/i,
                    inside: Prism.languages.markup.tag.inside
                },
                punctuation: /^\s*=\s*['"]|['"]\s*$/,
                "attr-value": {
                    pattern: /.+/i,
                    inside: Prism.languages.css
                }
            },
            alias: "language-css"
        }
    }, Prism.languages.markup.tag)), Prism.languages.clike = {
        comment: [{
            pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
            lookbehind: !0
        }, {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: !0
        }],
        string: {
            pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: !0
        },
        "class-name": {
            pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
            lookbehind: !0,
            inside: {
                punctuation: /(\.|\\)/
            }
        },
        keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
        boolean: /\b(true|false)\b/,
        function: /[a-z0-9_]+(?=\()/i,
        number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
        operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
        punctuation: /[{}[\];(),.:]/
    }, Prism.languages.javascript = Prism.languages.extend("clike", {
        keyword: /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
        number: /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
        function: /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
        operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
    }), Prism.languages.insertBefore("javascript", "keyword", {
        regex: {
            pattern: /(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
            lookbehind: !0,
            greedy: !0
        }
    }), Prism.languages.insertBefore("javascript", "string", {
        "template-string": {
            pattern: /`(?:\\\\|\\?[^\\])*?`/,
            greedy: !0,
            inside: {
                interpolation: {
                    pattern: /\$\{[^}]+\}/,
                    inside: {
                        "interpolation-punctuation": {
                            pattern: /^\$\{|\}$/,
                            alias: "punctuation"
                        },
                        rest: Prism.languages.javascript
                    }
                },
                string: /[\s\S]+/
            }
        }
    }), Prism.languages.markup && Prism.languages.insertBefore("markup", "tag", {
        script: {
            pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
            lookbehind: !0,
            inside: Prism.languages.javascript,
            alias: "language-javascript"
        }
    }), Prism.languages.js = Prism.languages.javascript,
    function(e) {
        e.languages.ruby = e.languages.extend("clike", {
            comment: [/#(?!\{[^\r\n]*?\}).*/, /^=begin(?:\r?\n|\r)(?:.*(?:\r?\n|\r))*?=end/m],
            keyword: /\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/
        });
        var t = {
            pattern: /#\{[^}]+\}/,
            inside: {
                delimiter: {
                    pattern: /^#\{|\}$/,
                    alias: "tag"
                },
                rest: e.util.clone(e.languages.ruby)
            }
        };
        e.languages.insertBefore("ruby", "keyword", {
            regex: [{
                pattern: /%r([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[gim]{0,3}/,
                greedy: !0,
                inside: {
                    interpolation: t
                }
            }, {
                pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]{0,3}/,
                greedy: !0,
                inside: {
                    interpolation: t
                }
            }, {
                pattern: /%r\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}[gim]{0,3}/,
                greedy: !0,
                inside: {
                    interpolation: t
                }
            }, {
                pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]{0,3}/,
                greedy: !0,
                inside: {
                    interpolation: t
                }
            }, {
                pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]{0,3}/,
                greedy: !0,
                inside: {
                    interpolation: t
                }
            }, {
                pattern: /(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\\\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,
                lookbehind: !0,
                greedy: !0
            }],
            variable: /[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/,
            symbol: /:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/
        }), e.languages.insertBefore("ruby", "number", {
            builtin: /\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,
            constant: /\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\b)/
        }), e.languages.ruby.string = [{
            pattern: /%[qQiIwWxs]?([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/,
            greedy: !0,
            inside: {
                interpolation: t
            }
        }, {
            pattern: /%[qQiIwWxs]?\((?:[^()\\]|\\[\s\S])*\)/,
            greedy: !0,
            inside: {
                interpolation: t
            }
        }, {
            pattern: /%[qQiIwWxs]?\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/,
            greedy: !0,
            inside: {
                interpolation: t
            }
        }, {
            pattern: /%[qQiIwWxs]?\[(?:[^\[\]\\]|\\[\s\S])*\]/,
            greedy: !0,
            inside: {
                interpolation: t
            }
        }, {
            pattern: /%[qQiIwWxs]?<(?:[^<>\\]|\\[\s\S])*>/,
            greedy: !0,
            inside: {
                interpolation: t
            }
        }, {
            pattern: /("|')(#\{[^}]+\}|\\(?:\r?\n|\r)|\\?.)*?\1/,
            greedy: !0,
            inside: {
                interpolation: t
            }
        }]
    }(Prism), Prism.languages.python = {
        "triple-quoted-string": {
            pattern: /"""[\s\S]+?"""|'''[\s\S]+?'''/,
            alias: "string"
        },
        comment: {
            pattern: /(^|[^\\])#.*/,
            lookbehind: !0
        },
        string: {
            pattern: /("|')(?:\\\\|\\?[^\\\r\n])*?\1/,
            greedy: !0
        },
        function: {
            pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,
            lookbehind: !0
        },
        "class-name": {
            pattern: /(\bclass\s+)[a-z0-9_]+/i,
            lookbehind: !0
        },
        keyword: /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,
        boolean: /\b(?:True|False)\b/,
        number: /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
        operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
        punctuation: /[{}[\];(),.:]/
    },
    function(e, t) {
        "use strict";
        if ("IntersectionObserver" in e && "IntersectionObserverEntry" in e && "intersectionRatio" in e.IntersectionObserverEntry.prototype) "isIntersecting" in e.IntersectionObserverEntry.prototype || Object.defineProperty(e.IntersectionObserverEntry.prototype, "isIntersecting", {
            get: function() {
                return 0 < this.intersectionRatio
            }
        });
        else {
            var n = [];
            r.prototype.THROTTLE_TIMEOUT = 100, r.prototype.POLL_INTERVAL = null, r.prototype.USE_MUTATION_OBSERVER = !0, r.prototype.observe = function(e) {
                if (!this._observationTargets.some(function(t) {
                        return t.element == e
                    })) {
                    if (!e || 1 != e.nodeType) throw new Error("target must be an Element");
                    this._registerInstance(), this._observationTargets.push({
                        element: e,
                        entry: null
                    }), this._monitorIntersections(), this._checkForIntersections()
                }
            }, r.prototype.unobserve = function(e) {
                this._observationTargets = this._observationTargets.filter(function(t) {
                    return t.element != e
                }), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance())
            }, r.prototype.disconnect = function() {
                this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance()
            }, r.prototype.takeRecords = function() {
                var e = this._queuedEntries.slice();
                return this._queuedEntries = [], e
            }, r.prototype._initThresholds = function(e) {
                var t = e || [0];
                return Array.isArray(t) || (t = [t]), t.sort().filter(function(e, t, n) {
                    if ("number" != typeof e || isNaN(e) || e < 0 || 1 < e) throw new Error("threshold must be a number between 0 and 1 inclusively");
                    return e !== n[t - 1]
                })
            }, r.prototype._parseRootMargin = function(e) {
                var t = (e || "0px").split(/\s+/).map(function(e) {
                    var t = /^(-?\d*\.?\d+)(px|%)$/.exec(e);
                    if (!t) throw new Error("rootMargin must be specified in pixels or percent");
                    return {
                        value: parseFloat(t[1]),
                        unit: t[2]
                    }
                });
                return t[1] = t[1] || t[0], t[2] = t[2] || t[0], t[3] = t[3] || t[1], t
            }, r.prototype._monitorIntersections = function() {
                this._monitoringIntersections || (this._monitoringIntersections = !0, this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (o(e, "resize", this._checkForIntersections, !0), o(t, "scroll", this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in e && (this._domObserver = new MutationObserver(this._checkForIntersections), this._domObserver.observe(t, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                }))))
            }, r.prototype._unmonitorIntersections = function() {
                this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), this._monitoringInterval = null, s(e, "resize", this._checkForIntersections, !0), s(t, "scroll", this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), this._domObserver = null))
            }, r.prototype._checkForIntersections = function() {
                var t = this._rootIsInDom(),
                    n = t ? this._getRootRect() : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    };
                this._observationTargets.forEach(function(r) {
                    var o = r.element,
                        s = a(o),
                        l = this._rootContainsTarget(o),
                        c = r.entry,
                        u = t && l && this._computeTargetAndRootIntersection(o, n),
                        d = r.entry = new i({
                            time: e.performance && performance.now && performance.now(),
                            target: o,
                            boundingClientRect: s,
                            rootBounds: n,
                            intersectionRect: u
                        });
                    c ? t && l ? this._hasCrossedThreshold(c, d) && this._queuedEntries.push(d) : c && c.isIntersecting && this._queuedEntries.push(d) : this._queuedEntries.push(d)
                }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
            }, r.prototype._computeTargetAndRootIntersection = function(n, i) {
                if ("none" != e.getComputedStyle(n).display) {
                    for (var r, o, s, l, u, d, g, h, p = a(n), m = c(n), f = !1; !f;) {
                        var y = null,
                            b = 1 == m.nodeType ? e.getComputedStyle(m) : {};
                        if ("none" == b.display) return;
                        if (m == this.root || m == t ? (f = !0, y = i) : m != t.body && m != t.documentElement && "visible" != b.overflow && (y = a(m)), y && (r = y, o = p, s = Math.max(r.top, o.top), l = Math.min(r.bottom, o.bottom), u = Math.max(r.left, o.left), h = l - s, !(p = 0 <= (g = (d = Math.min(r.right, o.right)) - u) && 0 <= h && {
                                top: s,
                                bottom: l,
                                left: u,
                                right: d,
                                width: g,
                                height: h
                            }))) break;
                        m = c(m)
                    }
                    return p
                }
            }, r.prototype._getRootRect = function() {
                var e;
                if (this.root) e = a(this.root);
                else {
                    var n = t.documentElement,
                        i = t.body;
                    e = {
                        top: 0,
                        left: 0,
                        right: n.clientWidth || i.clientWidth,
                        width: n.clientWidth || i.clientWidth,
                        bottom: n.clientHeight || i.clientHeight,
                        height: n.clientHeight || i.clientHeight
                    }
                }
                return this._expandRectByRootMargin(e)
            }, r.prototype._expandRectByRootMargin = function(e) {
                var t = this._rootMarginValues.map(function(t, n) {
                        return "px" == t.unit ? t.value : t.value * (n % 2 ? e.width : e.height) / 100
                    }),
                    n = {
                        top: e.top - t[0],
                        right: e.right + t[1],
                        bottom: e.bottom + t[2],
                        left: e.left - t[3]
                    };
                return n.width = n.right - n.left, n.height = n.bottom - n.top, n
            }, r.prototype._hasCrossedThreshold = function(e, t) {
                var n = e && e.isIntersecting ? e.intersectionRatio || 0 : -1,
                    i = t.isIntersecting ? t.intersectionRatio || 0 : -1;
                if (n !== i)
                    for (var r = 0; r < this.thresholds.length; r++) {
                        var o = this.thresholds[r];
                        if (o == n || o == i || o < n != o < i) return !0
                    }
            }, r.prototype._rootIsInDom = function() {
                return !this.root || l(t, this.root)
            }, r.prototype._rootContainsTarget = function(e) {
                return l(this.root || t, e)
            }, r.prototype._registerInstance = function() {
                n.indexOf(this) < 0 && n.push(this)
            }, r.prototype._unregisterInstance = function() {
                var e = n.indexOf(this); - 1 != e && n.splice(e, 1)
            }, e.IntersectionObserver = r, e.IntersectionObserverEntry = i
        }

        function i(e) {
            this.time = e.time, this.target = e.target, this.rootBounds = e.rootBounds, this.boundingClientRect = e.boundingClientRect, this.intersectionRect = e.intersectionRect || {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            }, this.isIntersecting = !!e.intersectionRect;
            var t = this.boundingClientRect,
                n = t.width * t.height,
                i = this.intersectionRect,
                r = i.width * i.height;
            this.intersectionRatio = n ? r / n : this.isIntersecting ? 1 : 0
        }

        function r(e, t) {
            var n, i, r, o = t || {};
            if ("function" != typeof e) throw new Error("callback must be a function");
            if (o.root && 1 != o.root.nodeType) throw new Error("root must be an Element");
            this._checkForIntersections = (n = this._checkForIntersections.bind(this), i = this.THROTTLE_TIMEOUT, r = null, function() {
                r || (r = setTimeout(function() {
                    n(), r = null
                }, i))
            }), this._callback = e, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(o.rootMargin), this.thresholds = this._initThresholds(o.threshold), this.root = o.root || null, this.rootMargin = this._rootMarginValues.map(function(e) {
                return e.value + e.unit
            }).join(" ")
        }

        function o(e, t, n, i) {
            "function" == typeof e.addEventListener ? e.addEventListener(t, n, i || !1) : "function" == typeof e.attachEvent && e.attachEvent("on" + t, n)
        }

        function s(e, t, n, i) {
            "function" == typeof e.removeEventListener ? e.removeEventListener(t, n, i || !1) : "function" == typeof e.detatchEvent && e.detatchEvent("on" + t, n)
        }

        function a(e) {
            var t;
            try {
                t = e.getBoundingClientRect()
            } catch (e) {}
            return t ? (t.width && t.height || (t = {
                top: t.top,
                right: t.right,
                bottom: t.bottom,
                left: t.left,
                width: t.right - t.left,
                height: t.bottom - t.top
            }), t) : {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            }
        }

        function l(e, t) {
            for (var n = t; n;) {
                if (n == e) return !0;
                n = c(n)
            }
            return !1
        }

        function c(e) {
            var t = e.parentNode;
            return t && 11 == t.nodeType && t.host ? t.host : t
        }
    }(window, document);
var setupRunKitNotebook = function(e) {
        if (window.RunKit) {
            var t = e.element,
                n = e.source,
                i = e.preamble,
                r = e.onLoad,
                o = e.onEvaluate,
                s = (e.container, RunKit.createNotebook({
                    element: t,
                    theme: "/connect" === location.pathname ? "stripe-light-connect" : "stripe-light",
                    gutterStyle: "inside",
                    nodeVersion: "8.x.x",
                    source: n,
                    preamble: i,
                    onLoad: r,
                    onEvaluate: o
                })),
                a = window.addEventListener("blur", function() {
                    if (document.activeElement === editor.querySelector("iframe")) {
                        var e = document.getElementById("runkit-warning"),
                            t = !1;
                        setInterval(function() {
                            s.getSource(function(n) {
                                var i = /\b(?:\d[ -]*?){13,16}\b/.test(n),
                                    r = n.indexOf("sk_live") > -1;
                                (i || r) && t || (t = !1, i ? (e.firstChild.innerHTML = 'Make sure you never send raw credit card numbers to Stripe. Use <a href="/docs/testing#cards">test tokens</a>, and integrate <a href="/docs/stripe.js">Stripe.js</a> or <a href="/docs/stripe-js/elements/quickstart">Elements</a> on your site.', t = !0) : r && (e.firstChild.innerHTML = 'Always use your test secret key for testing, not your live secret key. Get your test secret key in the <a href="https://dashboard.stripe.com/account/apikeys">Dashboard</a>.', t = !0), e.classList.toggle("visible", i || r))
                            })
                        }, 250)
                    }
                    window.removeEventListener("blur", a)
                });
            return s
        }
    },
    observeRunKitScroll = function(e, t) {
        var n = new IntersectionObserver(function(e) {
            e[0].intersectionRatio < .1 || (t(), n.disconnect())
        }, {
            threshold: .1
        });
        n.observe(e)
    };
! function() {
    "use strict";
    var e = document.getElementById("app-illustrations"),
        t = document.querySelector("#complete-toolkit .common-Link"),
        n = function() {
            Strut.isMobileViewport ? e.style.top = t.offsetTop + "px" : e.removeAttribute("style")
        };
    ["load", "resize"].forEach(function(e) {
        window.addEventListener(e, n)
    }), window.addEventListener("resize", n), window.addEventListener("load", function() {
        n(), e.classList.remove("hidden-preload")
    })
}(),
function() {
    "use strict";
    var e, t = document.getElementById("notebook"),
        n = t.querySelector("nav"),
        i = n.querySelector("select"),
        r = document.getElementById("api-method-selection"),
        o = n.querySelector("ul"),
        s = Strut.queryArray("button", o),
        a = document.getElementById("editor"),
        l = document.getElementById("prism"),
        c = l.querySelector(".custom-line-numbers"),
        u = l.querySelector(".language-javascript"),
        d = document.getElementById("runkit"),
        g = readConfig("runkit-notebook-config"),
        h = g.runkitConfig.sources,
        p = g.runkitConfig.epilogues,
        m = g.runkitConfig.preambles,
        f = function() {
            var t = i.selectedIndex;
            y(t);
            var n, r, o = i.options[t].value,
                s = h[o];
            u.textContent = s, n = s, r = function(e, t, i) {
                return e || (e = 1, t = n.split("\n").length, i = ""), t == e ? i + e : r(e + 1, t, i + e + "\n")
            }, c.textContent = r(), Prism.highlightElement(u), window.RunKit && e && (e.setSource(h[o] + (p[o] || "")), e.setPreamble(m[o] || ""))
        };
    g.enabled && !Strut.isMobileViewport && observeRunKitScroll(document.getElementById("primary"), function() {
        if (!e) {
            var r = i.options[i.selectedIndex].value;
            e = setupRunKitNotebook({
                container: t,
                element: d,
                source: h[r] + p[r],
                preamble: m[r],
                onLoad: function() {
                    a.classList.add("runkit")
                },
                onEvaluate: function() {
                    window.Analytics && Analytics.action("runkit_evaluate", {
                        section: r
                    })
                }
            }), l.addEventListener("transitionend", function(e) {
                l.style.display = "none", d.style.position = "relative", n.style.top = "2px"
            }), window.Analytics && Analytics.action("runkit_load", {
                section: r
            })
        }
    });
    var y = function(e) {
        s.some(function(e) {
            if (e.classList.contains("selected")) return e.classList.remove("selected"), !0
        }), s[e].classList.add("selected"), r.style.transform = "translateY(" + 100 * e + "%)"
    };
    o.addEventListener("click", function(e) {
        "button" == e.target.nodeName.toLowerCase() && (i.selectedIndex = s.indexOf(e.target), f(), window.siteAnalytics && window.siteAnalytics.trackHomePageNotebook && window.siteAnalytics.trackHomePageNotebook(e.target))
    }), i.addEventListener("change", f), f(), Strut.load.css("v3/shared/prism_light.css")
}(), Strut.supports.es6 && Strut.load.js("v3/home/animations.js");